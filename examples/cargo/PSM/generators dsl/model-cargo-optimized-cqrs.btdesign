Application Cargo {
  basePackage = org.cargo
 
  Module command {
 
    Entity Cargo {
		aggregateRoot
		- @RouteSpecification routespecification
		- @Itinerary itinerary nullable inverse opposite cargo
		- @Role receiever
		- @Role sender
		- @TrackingID trackingId key
	
		Repository CargoRepository {
			protected populateAssociations;
            save(@Cargo cargo) publish to cargoChannel;
			@TrackingID nextTrackingId();
			detachItineray(@Cargo cargo);
			"Delete orphaned itineraries - conceptually the responsibility
			of the Cargo aggregate"
			protected deleteOrphanItinerary => AccessObject;
		}
	}
	"Uniquely identifies a particular cargo. Automatically generated by the application."
	ValueObject TrackingID {
		nogap
		String id key databaseColumn=""
	}
	ValueObject Delivery {
		!persistent
				 
		Boolean misdirected
		Date eta
		Boolean isUnloadedAtDestination
		Date calculatedAt
		
		- @TransportStatus transportStatus
		- @Location lastKnownLocation
		- @Voyage currentVoyage
		- @HandlingActivity nextExpectedActivity
		- @RoutingStatus routingStatus
		- @HandlingEvent lastEvent
	}
	ValueObject HandlingActivity {
		belongsTo Cargo
		
		- @HandlingEventType handlingEventType
		- @Location location
		- @Voyage voyage
	}	
	ValueObject Itinerary {
		belongsTo Cargo
		!optimisticLocking
		!immutable
		
		- @Cargo cargo nullable opposite itinerary
		- List<@Leg> legs inverse orderColumn
	}
	"An itinerary consists of one or more legs."
	ValueObject Leg {
		belongsTo Cargo
		
		Date loadTime nullable
		Date unLoadTime nullable
		
		- @VoyageNumber voyageNumber
		- @Location loadLocation
		- @Location unloadLocation
	}
	ValueObject RouteSpecification {
		belongsTo Cargo
		
		Date arrivalDeadline
		- @Location origin
		- @Location destination
	}
	enum TransportStatus {
		NOT_RECEIVED, IN_PORT, ONBOARD_CARRIER, CLAIMED, UNKNOWN
	}
 
    enum RoutingStatus {
		NOT_ROUTED, ROUTED, MISROUTED
	}
	
	DomainEvent ACargoBooked {
		Date arrivalDeadline

		- @TrackingID trackingID
		- @Location originLocation
		- @Location destinationLocation
		- @RoutingStatus routingStatus
	}
    DomainEvent CargoDestinationChanged {
    	- @TrackingID trackingID
    	- @Location oldDestination
    	- @Location newDestination
	}
    DomainEvent CargoAssignedToRoute {
    	- @TrackingID trackingID
    	- @Itinerary itinerary
    	- @RoutingStatus routingStatus
	}
	abstract DomainEvent CargoUpdateEvent{
		- @TrackingID trackingID
	}
	DomainEvent CargoIsClaimedEvent extends CargoUpdateEvent{
		
	}
    DomainEvent NextExpectedHandlingActivity extends CargoUpdateEvent{	
    	- @HandlingEventType type
    	- @VoyageNumber voyageNumber
    	- @Location location
	}
    DomainEvent CargoTransportStatusRecalculated extends CargoUpdateEvent{
    	- @TransportStatus transportStatus
	}
    DomainEvent CargoLastKnownUpdated extends CargoUpdateEvent {
    	- @Location location
	}
    DomainEvent CargoCurrentVoyageUpdated {
    	- @VoyageNumber voyageNumber
	}
    DomainEvent CargoIsUnloadedAtDestination extends CargoUpdateEvent{
	}
	
	
	CommandEvent BookingANewCargoCommand {
		String originUnlocode nullable
		String destinationUnlocode nullable
		String arrivalDeadline nullable
	}
	CommandEvent UpdateEventOfCargoCommand extends HandlingEventCommand{
	}
	CommandEvent ChangeDestinationCommand {
		- @TrackingID trackingID
		- @Location location
	}
    CommandEvent AssignCargoToRouteCommand {
    	- @TrackingID trackingID
    	- @Itinerary itinerary
	}
	Service BookingService {
		changeDestination(@ChangeDestinationCommand command); 
	    assignCargoToRoute(@AssignCargoToRouteCommand command);
	    bookingNewCargo(@BookingANewCargoCommand command) => InternalBookingService.bookNewCargo;
	}
    Service InternalBookingService {  
	     inject @CargoRepository	   
	       
	    changeDestination(@TrackingID trackingID, @Location location) 
	    	publish @CargoDestinationChanged to bookingChannel; 
	    "Assigns a cargo to route."
        void assignCargoToRoute(@TrackingID trackingId, @Itinerary itinerary) 
        	publish @CargoAssignedToRoute to bookingChannel
        	throws CargoNotFoundException;
		
		"Registers a new cargo in the tracking system, not yet routed."
		@TrackingID bookNewCargo(@Location origin, @Location destination, Date deadline) 
			publish @ACargoBooked to bookingChannel
			throws LocationNotFoundException;
	}	
 	
 	// ------------------------
 	// Report Aggregate
 	
 	abstract DomainEvent HandlingEvent {	
		Date registrationTime
		Date completionTime
		
		- @HandlingEventType handlingType
		- @Voyage voyage
		- @Location location
		- @Cargo cargo
	}
	
	 abstract DomainEvent HandlingEventCommand {	
		Date registrationTime
		Date completionTime
		
		- @HandlingEventType handlingType
		- @Voyage voyage
		- @Location location
		- @Cargo cargo
	}
	
	DomainEvent HandlingEventRegistered extends HandlingEvent{
		aggregateRoot
		persistent
				
		Repository HandlingEventRepository {
 			@HandlingHistory lookupHandlingHistoryOfCargo(TrackingId trackingId);
		}
	}
	
	ValueObject HandlingHistory {
		belongsTo HandlingEventRegistered
		- Set<@HandlingEventRegistered> handlingEvents
	}
	
    CommandEvent RegisterHandlingEventCommand extends HandlingEventCommand{
	}
	
	enum HandlingEventType {
		UNLOAD, 
		CUSTOMS, 
		CLAIM, 
		LOAD, 
		RECEIVE 
	}
	
	Service CargoReportService{
		subscribe to handlingEventChannel
		inject @CargoRepository
		updateEventOfCargo(@HandlingEventRegistered event) publish @CargoUpdateEvent to cargoReportChannel; 
	}
	
	Service InternalHandlingService {
	     registerHandlingEvent(Date completionTime, @TrackingID trackingID, @Location location, @HandlingEventType handlingType, @VoyageNumber voyageNumber) publish @HandlingEventRegistered to handlingEventChannel; 
	}
 
    Service HandlingService {
	     registerHandlingEvent(@RegisterHandlingEventCommand command) => InternalHandlingService.registerHandlingEvent; 
	}
	
 	// ------------------------
 	// Voyage Aggregate
 	
    Entity Voyage {
    	aggregateRoot
		- @VoyageNumber voyageNumber
		- @Schedule schedule
	
		Repository VoyageRepository {
		}
	}
	
	ValueObject VoyageNumber {
		belongsTo Voyage
		String number key
	}
 
 	ValueObject CarrierMovement {
		Date departureTime
		Date arrivalTime
		- @Location arrivalLocation
		- @Location departureLocation
	}
	
	ValueObject Schedule {
		- Set<@CarrierMovement> carrierMovements
	}
	
	// ------------------------
	// Location Aggregate
   
    Entity Location {
		String unlocode nullable
		String portCode nullable
		String name nullable
		
	
		Repository LocationRepository {
 			@Location find(@Location location);
			List<@Location> findAll();
			protected findByKeys;
		}
	}
	
	Service LocationInternalService {
		find => LocationRepository.find;
		findAll => LocationRepository.findAll;
    }
    
 	// ------------------------
	// Customer Aggregate
    Entity Customer {
		String name nullable
		
		Repository CustomerRepository {
		}
	}
 
    ValueObject Role {
		- @Customer customer
		- @Cargo cargo
	}  
  }
  
  Module ^query{
  	Entity CargoItem {
		aggregateRoot
		String nextExpectedHandlingActivityType
		String nextExpectedHandlingActivityLocation
		String nextExpectedHandlingActivityVoyageNumber
		String lastKnownLocation
		String unloadedAtDestinationIndicator
		Date arrivalDeadline
				
		- @Location originLocation
		- @Location destLocation
		- @RoutingStatus routingStatus
		- @TransportStatus transportStatus
		- @VoyageNumber currentVoyageNumber
		- @TrackingID trackingID key
		- @LegItem legs
		
		Repository CargoItemRepository {
			subscribe to cargoChannel
			@CargoItem find(@TrackingID trackingId) throws CargoNotFoundException => FindCargoAccessObject;
			@CargoItem find(@TrackingID trackingId, boolean loadDeliveryHistory) throws CargoNotFoundException;
			List<@CargoItem> findAll;
			save;
			delete;
			@TrackingID nextTrackingId();
			protected findById;
		}
	}
	
	Entity LegItem {
		String voyageNumber
		Date loadTime
		Date unLoadTime
		
		- @Location origin
		- @Location destination
	}
	
	Service CargoQueryService {
		"Requests a list of itineraries describing possible routes for this cargo."
        List<@LegItem> requestPossibleRoutesForCargo(@TrackingID trackingId)
                throws CargoNotFoundException,
                    LocationNotFoundException;	 
		List<@CargoListDTO> getCargoesItems();
		@CargoDetailsDTO getCargoItemDetails();
		protected findLocation => LocationInternalService.find;
        protected fetchRoutes => RoutingService.fetchRoutesForSpecification;
	}
	
	Service CargoQueryInternalService {
		"Requests a list of itineraries describing possible routes for this cargo."
         List<@LegItem> requestPossibleRoutesForCargo(@TrackingID trackingId)
                throws CargoNotFoundException,
                    LocationNotFoundException;	 
		List<@CargoItem> getCargoesItems();
		@CargoItem getCargoItemDetails();
	}
	
	Service RoutingService {
	  "A list of itineraries that satisfy the specification. May be an empty list if no route is found."
        List<@LegItem> fetchRoutesForSpecification(@RouteSpecification routeSpecification)
			throws LocationNotFoundException;
		listOfShippingLocation => LocationInternalService.findAll;
		protected findLocation => LocationInternalService.find;
	}
	
	Service TrackingService {
		inject @CargoRepository

		"Track a particular cargo."
        @Cargo track(@TrackingID trackingId) throws CargoNotFoundException;

		"Inspect cargo and send relevant notifications to interested parties,
		for example if a cargo has been misdirected, or unloaded
		at the final destination."
        void inspectCargo(@TrackingID trackingId) throws CargoNotFoundException;
    }
		
	DataTransferObject PossibleRouteForCargoDTO {	
		- List<@LegItem> lges
	}
    DataTransferObject BookingFormDTO {
		- @ShippingLocationsDTO locations
	}
    DataTransferObject ChangeDestinationFormDTO {
    	- @TrackingID trackingID
    	- @ShippingLocationsDTO locations
	}
    //DataTransferObject CargoWithHandlingEventsDTO {
	//}
    DataTransferObject CargoDetailsDTO {
    	String nextExpectedHandlingActivityType
		String nextExpectedHandlingActivityLocation
		String nextExpectedHandlingActivityVoyageNumber
		String lastKnownLocation
		String unloadedAtDestinationIndicator
		Date arrivalDeadline
				
		- @Location originLocation
		- @Location destLocation
		- @RoutingStatus routingStatus
		- @TransportStatus transportStatus
		- @VoyageNumber currentVoyageNumber
		- @TrackingID trackingID key
		- @LegItem legs
	}
	DataTransferObject CargoListDTO{
		- @Location originLocation
		- @Location destLocation
		- @RoutingStatus routingStatus
		- @TransportStatus transportStatus
		- @VoyageNumber currentVoyageNumber
		- @TrackingID trackingID key
		Date arrivalDeadline
	}
	DataTransferObject ShippingLocationsDTO {
		- List<@Location> location
	}
    DataTransferObject LocationDetailsDTO {	
		- @Location location
	}
	DataTransferObject ReportFormDTO {
		- CargoListDTO cargoes
	}
  }
  
  
  
  Module rest{
  	Resource RegistrationResource {
  		path = "/cargoes/registration"
  		bookingFormView();
  		bookingNewCargo();
	}
    Resource TrackingResource {
    	path = "/cargoes/tracking"
	}
    Resource CargoesResource {
    	path = "/cargoes"
	    trackACargo;
	    cargoListView; 
	    requestPossibleRoutesForCargo; 
 
	}
    Resource CargoResource {
    	path = "/cargoes/{trackingID}"
		cargoDetailsView; 
	}
    Resource Destination {
    	path = "/cargoes/{trackingID}/destination"
		pickNewDestinationView;
		changeDestination;  
	}
    Resource RoutesResource {
    	path = "/cargoes/{trackingID}/routes"
		assignCargoToRoute; 
	}
	Resource CustomersResource {
	}
	Resource LocationsResource {
		path = "/locations/"
	    listOfShippingLocation => RoutingService.listOfShippingLocation; 
	    findLocation => RoutingService.findLocation; 
	}
	Resource VoyagesResource {
	}
	Resource HandlingsResource {
		path = "/report/"
	    reportFormView; 
	    registerHandlingEvent => HandlingService.registerHandlingEvent; 
	}
  }
}

